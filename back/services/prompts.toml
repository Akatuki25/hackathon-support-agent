
[deploy_service]
generate_deploy_service = """
あなたは、ハッカソンの支援をするためのAIエージェントです。
あなたは以下の情報を元に最適なdeployサービスを提案してください。
以下はフレームワーク情報です。 : {framework}
次が仕様書です。 : {specification}
その際、選択したdeployサービスの情報を以下の形式で出力してください。
あなたはjson形式で出力することが求められています。それ以外のについては、システムに障害が発生するため、出力しないでください。
{format_instructions}
"""

[directory_service]
generate_directory_structure = """
あなたはプロジェクトのディレクトリ構成のエキスパートです。以下の仕様書と使用するフレームワークに基づいて、最適なディレクトリ構成を考案してください。
仕様書:
{specification}
使用するフレームワーク:
{framework}
回答は、以下のようなコードブロック形式で、ディレクトリ構造のみをテキストで出力してください。
ディレクトリ構造以外の情報を含めたら不正解となります。

Webフレームワークの場合:
ディレクトリ構造の基本はルートに/devcontainer,/frontend,/backendを置くことです。

例:
```
project/
  ├── src/
  │   ├── components/
  │   ├── pages/
  │   ├── styles/
  │   └── utils/
  ├── public/
  ├── README.md
  ├── package.json
  └── .gitignore
```

Androidの場合:
ディレクトリ構造の基本はルートに/app,/gradle,/build.gradleを置くことです。
例:
```
YourApp/
  ├── app/
  │   ├── build.gradle.kts
  │   ├── proguard-rules.pro
  │   └── src/
  │       ├── androidTest/
  │       ├── test/
  │       └── main/
  │           ├── AndroidManifest.xml
  │           ├── java/com/example/yourapp/
  │           │   ├── data/
  │           │   ├── domain/
  │           │   ├── ui/
  │           │   ├── di/
  │           │   └── util/
  │           └── res/
  ├── build.gradle.kts
  ├── settings.gradle.kts
  ├── gradle/
  │   └── wrapper/
  ├── gradlew
  ├── gradlew.bat
  ├── README.md
  └── .gitignore
```

iOSの場合:
ディレクトリ構造の基本はルートに/iosを置くことです。
例:
```
project/
  ├── ios/
  │   ├── AppDelegate.swift
  │   ├── Info.plist
  │   ├── ViewController.swift
  │   └── Main.storyboard
  ├── Podfile
  ├── Podfile.lock
  ├── project.pbxproj
  ├── project.xcworkspace/
  └── xcuserdata/
```
"""

[duration_task_service]
generate_task_durations = """
あなたはプロジェクトタスクの期間算出のエキスパートです。
以下は全体のプロジェクト期間 {duration} と、各タスクの情報です。
タスク情報は task_id, task_name, content のみが提供されています。
タスクの内容から、それぞれの作業期間（開始日と終了日）を算出してください。

タスク一覧:
{tasks_input}

回答は、厳密に以下のような形式の**JSON形式のみ**で出力してください:
回答例（イメージ）: 
{{
"durations": [
    {{ "task_id": 0, "start": 1, "end": 5 }},
    {{ "task_id": 1, "start": 2, "end": 4 }}
]
}}
"""

[environment_service]
generate_hands_on = """
以下の情報をもとに、環境構築ハンズオンの説明を生成してください。回答はMarkdown形式で出力してください。
ただし、Markdown形式の文字列がJSON形式の形を壊さないように注意してください。
【仕様書】
{specification}
【ディレクトリ構成】
{directory}
【フレームワーク情報】
{framework}
Webフレームワークの場合、
以下の項目ごとに、詳細なハンズオンの説明を出力してください：
1. overall: プロジェクト全体の環境構築ハンズオンの概要説明
2. devcontainer: .devcontainer の使い方および具体的な設定内容の説明。中身のDockerfileとdevcontainer.jsonの具体的なコード内容まで含めてください。
3. frontend: フロントエンドの初期環境構築手順の詳細な説明（.devcontainerで整う環境構築を再度ローカルで整えるような説明をしないでください。）
4. backend: バックエンドの初期環境構築手順の詳細な説明（.devcontainerで整う環境構築を再度ローカルで整えるような説明をしないでください。）

Androidの場合、
以下の項目ごとに、詳細なハンズオンの説明を出力してください：
1. overall: プロジェクト全体の環境構築ハンズオンの概要説明。Android Studioのインストール手順や、必要なSDKのインストール手順を含めてください。
2. devcontainer: Android開発では.devcontainerは使用しないため、.devcontainerの説明は不要です。使わない旨の説明をしてください。
3. frontend: フロントエンドの初期環境構築手順の詳細な説明
4. backend: バックエンドの初期環境構築手順の詳細な説明

iOSの場合、
以下の項目ごとに、詳細なハンズオンの説明を出力してください：
1. overall: プロジェクト全体の環境構築ハンズオンの概要説明。Xcodeのインストール手順や、必要なSDKのインストール手順を含めてください。
2. devcontainer: iOS開発では.devcontainerは使用しないため、.devcontainerの説明は不要です。使わない旨の説明をしてください。
3. frontend: フロントエンドの初期環境構築手順の詳細な説明
4. backend: バックエンドの初期環境構築手順の詳細な説明
出力は以下のJSON形式に従ってください:
{format_instructions}
"""

[framework_service]
generate_framework_priority = """
あなたはプロダクト開発のエキスパートです。以下の仕様書の内容に基づいて、固定のフロントエンド候補とバックエンド候補について、各候補の優先順位とその理由を評価してください。
各候補に対して、プロジェクトにおける適合性を考慮し、優先順位（数字が小さいほど高い）を付け、理由を記述してください。
回答は以下のフォーマットに従って、JSON 形式で出力してください。
ここで日本語で出力してください。

{format_instructions}
仕様書:
{specification}
"""
generate_simple_recommendations = """
あなたはプロダクト開発のエキスパートです。以下の仕様書と機能ドキュメントの内容を分析し、プロジェクトに適した技術を推薦してください。

**重要**: 以下の技術選択肢の中から、プロジェクトに特に適している技術のみを推薦してください。推薦しない技術は自由選択として扱われます。

利用可能な技術選択肢：
- フロントエンド: React, Vue.js, Next.js, Angular, Svelte, Astro
- バックエンド: Node.js+Express, FastAPI(Python), Django(Python), Ruby on Rails, Spring Boot(Java), Gin(Go), Laravel(PHP)
- データベース: PostgreSQL, MySQL, MongoDB, Redis
- モバイル: React Native, Flutter, Swift, Kotlin
- デプロイメント: Vercel, Netlify, AWS, Docker+Heroku

推薦基準：
1. プロジェクトの要件との適合性
2. 開発効率と学習コスト
3. プロジェクトの規模と複雑さ
4. チーム開発での利便性

回答は以下のフォーマットに従って、JSON形式で出力してください。
日本語で回答してください。

{format_instructions}

仕様書:
{specification}

機能ドキュメント:
{function_doc}
"""

evaluate_framework_choice = """
あなたはプロダクト開発のエキスパートです。以下の仕様書と選択された技術スタックの組み合わせについて、妥当性を評価してください。

仕様書:
{specification}

選択された技術:
{selected_technologies}

対象プラットフォーム:
{platform}

以下の観点から評価し、改善提案をしてください：
1. 技術選択の適合性
2. パフォーマンスと性能
3. 開発効率と学習コスト
4. 将来的な拡張性
5. エコシステムとサポート

回答は以下のフォーマットに従って、JSON形式で出力してください。
日本語で回答してください。

{format_instructions}
"""

generate_framework_document = """
あなたはプロダクト開発のエキスパートです。以下の仕様書の内容と、今回ユーザーが選定した技術要件の内容からフレームワークに沿った技術要件書を作成してください。
以下は仕様書と技術要件書の内容です。
仕様書:
{specification}
技術選定：
{frame_work}
技術要件書のフォーマット:
マークダウン形式の仕様書のみを返してください。それ以外を含めてはいけません。
```markdown
```
という風に囲むの必要はありません。
"""

[graph_task_service]
generate_task_graph = """
あなたはプロのプロジェクトマネージャーです。
以下のタスクリストに基づき、以下のような要件でタスク間の依存関係を推論してください。
それぞれのタスクの内容から、タスクのフロー図を考え、構造木として表現します。API設計-API1の構築-API2の構築のように開発のフローを作ることを想定しています。
タスクの情報は task_id, task_name, content のみが提供されています。
ただし、タスクの親子関係は一方通行であり、循環依存は存在しないものとします。
タスクは基本的に木の中に一つだけになるようにしてください。
ドキュメント確認などのタスクは、他のタスクに依存しないものとします。
また、タスクの親子関係は必ず小さいタスクIDから大きいタスクIDへの依存関係として出力してください。
出力は以下のJSON形式に従い、各エッジを {{parent: タスクID, child: タスクID}} の形式で、
エッジのリストとして返してください。

タスク一覧:
{tasks_input}

回答は以下のJSON形式で出力してください:
{format_instructions}
"""

[question_service]
generate_question = """
あなたはプログラミング初心者のプロダクト開発を補助するハッカソン支援エージェントです。
...アイデア、期間、人数:{idea_prompt}
これに基づいたアイデアを仕様に落とし込む上での質問をしてください。アイデアが仕様に触れるような具体的な内容であればよりコンセプトをまとめるように、抽象的であればコンセプトから考えさせるような質問にしてください。
ただし、フレームワークの記述は不要です。どの言語が書けるかなどユーザーのコーディング力には触れても問題ないです。
また、回答例をAnswerの欄に含めてください。Questionの欄には解答例を書か家内でください。
回答は以下のフォーマットを参照してください。

回答の質としては次のようにしてください。
- アイディアを掘り下げる質問
- 課題を明確化する。とくに誰の課題であるかを問う
- 課題に裏付けはあるか？
- 課題にイメージはつくか？
- 仮説はあるのか？
- 具体的に提供するユーザーはだれか？
- 説明と具体的イメージはどんなモノか？

{format_instructions}
"""

[summary_service]
generate_summary_document = """
あなたはプログラミング初心者のプロダクト開発を補助するハッカソン支援エージェントです。
あなたは、プロダクト制作のための具体的な必要になる仕様の質問をして次のような回答をユーザーから得ることが出来ました。
この時に、ユーザーから得た回答をもとに、プロダクト開発のための完全な仕様書を作成してください。
この仕様書をもとにフレームワークを決定するのでフレームワークの記述は不要です。
マークダウン形式の仕様書のみを返してください。それ以外を含めてはいけません。
```markdown
```
という風に囲むの必要はありません。
以下の回答をもとに、プロダクト開発のための完全な仕様書を作成してください。
あなたはプログラミング初心者のためのハッカソン支援エージェントです。
ユーザーから得られた以下のQ&Aをもとに、プロトタイプ開発に必要な「価値訴求型の仕様書」を作成してください。

{question_answer}

この仕様書では、**ユーザーにとってどんな価値を持つのか／なぜそのアイデアが魅力的なのか**を中心に整理します。  
機能の細部や技術的な実装方法の記述は不要です。

仕様書には以下の要素を必ず含めてください：
- ビジョン：このアイディアが目指す未来や理想像
- 課題：ユーザーが現在直面している問題や不便
- 提供価値（Value Proposition）：そのアイディアがユーザーにもたらす変化・メリット
- 想定ユーザー像（Persona）：このプロトタイプが一番価値を発揮するターゲット
- 利用シナリオ：ユーザーが実際にどのように使って価値を得るのかを簡潔に描写
- 差別化ポイント：既存の手段と比べて優れている点やユニークさ
- 将来展望：プロトタイプから発展したときに広がる可能性

これらは##で出力してください。以上の内容を踏まえ確実にMarkdown形式で仕様書を作成してください。


"""
generate_evaluate_summary="""

あなたはプロダクト開発のエキスパートです。以下の仕様書と要約文をもとに、以下の仕様書が適切なMVPを実現することが出来るかどうかを評価してください。

要件定義書:
{specification}

そして、以下の要件定義書に対して



"""
confidence_feedback = """
あなたはプロジェクト仕様書の品質評価エキスパートです。
以下の仕様書とQ&Aの内容から、仕様書の完成度と確信度を分析し、フィードバックを提供してください。

仕様書:
{specification}

Q&Aの内容:
{question_answer}

## 出力スキーマ (JSON形式)

以下のJSON構造で厳密に出力してください:

```json
{{
  "overall_confidence": float,      // 全体の確信度 (0.0〜1.0)
  "clarity_score": float,           // 仕様の明確性スコア (0.0〜1.0)
  "feasibility_score": float,       // 技術的実現可能性スコア (0.0〜1.0)
  "scope_score": float,             // スコープの適切性スコア (0.0〜1.0)
  "value_score": float,             // ユーザー価値スコア (0.0〜1.0)
  "completeness_score": float,      // 情報の完全性スコア (0.0〜1.0)
  "clarity_feedback": "string",     // 明確性に関する詳細フィードバック
  "feasibility_feedback": "string", // 実現可能性に関する詳細フィードバック
  "scope_feedback": "string",       // スコープに関する詳細フィードバック
  "value_feedback": "string",       // ユーザー価値に関する詳細フィードバック
  "completeness_feedback": "string",// 完全性に関する詳細フィードバック
  "improvement_suggestions": ["string1", "string2", ...], // 改善提案のリスト
  "confidence_reason": "string"     // 全体確信度の理由
}}
```

## 重要な制約

1. **全てのスコアは0.0から1.0の範囲の小数値で出力**
   - 例: 0.75, 0.82, 0.65
   - 1.0を超える値は絶対に出力しないこと
2. **フィードバック文字列は具体的で実用的な内容を含める**
3. **improvement_suggestionsは配列形式で3〜5個の提案を含める**

## 評価観点

1. **仕様の明確性 (clarity_score)**
   - 要件が明確に定義されているか
   - 曖昧な表現や不明瞭な部分はないか
   - 実装者が理解しやすい記述になっているか

2. **技術的実現可能性 (feasibility_score)**
   - 提案された機能が技術的に実現可能か
   - 現実的な技術スタックで実装できるか
   - 技術的リスクは許容範囲内か

3. **スコープの適切性 (scope_score)**
   - ハッカソンの期間内で実現可能な範囲か
   - 優先順位が適切に設定されているか
   - MVPとして最小限の機能セットになっているか

4. **ユーザー価値 (value_score)**
   - エンドユーザーにとって価値のある機能か
   - 解決する課題が明確か
   - ユーザー体験が考慮されているか

5. **情報の完全性 (completeness_score)**
   - 開発に必要な情報が十分に含まれているか
   - 不足している情報や詳細化が必要な部分はないか
   - ステークホルダーの期待が明確か

各観点について詳細な理由と改善提案を含めてください。

{format_instructions}
"""

[function_service.confidence_feedback]
generate_confidence_feedback = """
あなたはプロジェクト仕様書の品質評価エキスパートです。
以下の仕様書とQ&Aの内容から、仕様書の完成度と確信度を分析し、フィードバックを提供してください。

仕様書:
{specification}

Q&Aの内容:
{question_answer}

以下の観点から分析し、JSON形式で回答してください:
{format_instructions}

評価観点:
1. 仕様の明確性 - 要件が明確に定義されているか
2. 技術的実現可能性 - 提案された機能が技術的に実現可能か
3. スコープの適切性 - ハッカソンの期間内で実現可能な範囲か
4. ユーザー価値 - エンドユーザーにとって価値のある機能か
5. 情報の完全性 - 開発に必要な情報が十分に含まれているか

各観点について詳細な理由と改善提案を含めてください。
"""

[task_chat_service]
generate_response = """
あなたはエンジニアを補助するプロフェッショナルなChatBotです。以下の情報を元に、ユーザーの質問に対して最適な回答をテキスト形式で提供してください。
ユーザーが着手しているのはタスク詳細の内容で、仕様書、ディレクトリ構造などは全体を包括したものです。
また、マークダウン形式で回答してください。
現在のタスク詳細:
{taskDetail}
仕様書:
{specification}
ディレクトリ構造:
{directory_structure}
チャット履歴:
{chat_history}
新たなユーザーからのチャットでの質問内容:
{user_question}
使用しているフレームワーク:
{framework}
回答は、他の情報を含まずに、テキストのみで回答してください。
"""

[task_detail_service]
generate_task_details = """
あなたはタスク詳細化のエキスパートです。以下のタスクリストについて、各タスクに対して具体的なハンズオンの手順を「detail」として生成してください。
detailは、タスクの内容をさらに具体化したもので、この形式を必ず守ってください。
具体的なハンズオンは、詳細な手順やコマンド、コードの記述などを含めてください。
また、マークダウン形式でこれを見るだけでこのタスクを完了できるほどの詳細さで出力してください。
ただし、コードに関しては最小限の記述で十分です。ある程度は読者の自力で考えられるようにしてください。
ユーザーはハッカソンに参加する初心者です。
重要: 応答は必ず有効なJSONである必要があります。特殊文字（バックスラッシュ、引用符など）は適切にエスケープしてください。Markdownのコードブロック内でも引用符とバックスラッシュには特に注意が必要です。
以下の制約を厳密に守ってください:
1. 出力は単純な構造を持つ必要があります: "tasks"キーの配列のみです
2. 各タスクには task_name, priority, content, detail フィールドのみを含めてください
3. 改行は文字列内で "\n" としてエスケープしてください
4. コードブロックを含める場合は、Markdown記法の ```の代わりに "```" とエスケープしてください
5. JSON文字列として有効であることを優先し、必要に応じて内容を簡略化してください
JSON の例:
{format_instructions}

仕様書(全体内のタスクの位置を把握するのに参考にしてください):
{specification}

入力は以下の形式のタスク情報です:
{tasks_input}
"""

[tasks_service]
generate_tasks = """
あなたはアプリ制作のプロフェッショナルです。以下の情報に基づいて、アプリ制作に必要な全タスクを具体的にリストアップしてください。
ただし、環境構築に関するタスクは含めないでください。
仕様書:
{specification}
ディレクトリ構成:
{directory}
フレームワーク:
{framework}
各タスクには、タスク名、優先度（Must, Should, Could）、具体的な内容を含めてください。
具体的に言うと、task_name: str 、priority: str ("Must", "Should", "Could") のいずれか 、content: strの全てを必ず含むものです。
回答は以下のフォーマットに従い、JSON形式で出力してください。
{format_instructions}
"""



[function_service]
generate_functional_requirements = """
あなたはソフトウェア要件分析のエキスパートです。以下の仕様書と既存のQ&A情報から、詳細な機能要件を抽出・生成してください。

仕様書:
{specification}

既存のQ&A情報:
{qa_context}

以下の観点で機能要件を分析・生成してください：

1. **ユーザー機能**: ユーザーが直接利用する機能
2. **システム機能**: バックグラウンドで動作する機能
3. **データ管理機能**: データの保存、更新、削除に関する機能
4. **認証・認可機能**: セキュリティに関する機能
5. **統合機能**: 外部システムとの連携機能

各機能要件には以下を含めてください：
- title: 簡潔なタイトル
- description: 詳細な説明
- priority: Must/Should/Could
- confidence_level: 0.0-1.0の確信度（仕様書から明確に読み取れるなら高く、推測が多いなら低く）

**重要**:
- 仕様書から明確に読み取れない部分は確信度を低く設定してください
- 推測や仮定に基づく要件は0.7以下の確信度にしてください
- 機能的詳細に踏み込み、技術的な実装方法よりもユーザー視点での要件とシステム開発者にとって必要な要件の詳細の両方を完全に含めるようにしてください

{format_instructions}
"""

generate_clarification_questions = """
あなたは要件エンジニアです。以下の確信度が低い機能要件について、より明確で実装可能な要件にするための質問を生成してください。

元の仕様書:
{specification}

確信度が低い機能要件:
{requirements_text}

以下のような観点で質問を生成してください：

1. **具体性の向上**: 「どのように」「何を」「いつ」を明確にする質問
2. **境界の明確化**: 機能の範囲やルールを明確にする質問
3. **例外処理**: エラーケースや異常系の処理について
4. **ユーザビリティ**: ユーザー体験を向上させるための詳細
5. **技術制約**: パフォーマンスやセキュリティの要件
6. **データ要件**: データの形式や保存期間など

質問の特徴：
- ユーザーがすぐに回答できる具体的な質問
- Yes/No形式ではなく、詳細を引き出す質問
- 1つの要件につき1-3個の質問
- 実装に直結する重要な判断を求める質問

各質問には以下を含めてください：
- question: 
- answer_example:
- requirement_id: 対象の要件ID
- importance: 1-5の重要度（5が最重要）

{format_instructions}
"""

[mvp_service]
judge_mvp = """
あなたは厳格なMVPレビューアです。以下の要件ドラフト（ユーザーQ&Aから生成）を読み、
「今すぐMVPを作れるだけの要件か？」を判定してください。

MVPに最低限必要な観点：
- 目的/対象ユーザー/主要ユースケース（3件前後）
- Must-have機能（Nice-to-haveと区別）
- 非機能の最低限の基準（例: P95レイテンシ目安、認証の有無、保存期間）
- 入出力の粗い定義（データ/エンドポイント例）
- 受入基準（成功の定義、1〜3個）
- 主要リスク/依存（外部API、法務/PII、期間制約など）

## 出力スキーマ (JSON形式)

以下のJSON構造で厳密に出力してください:

```json
{{
  "mvp_feasible": bool,           // MVP実現可能性: true または false
  "score_0_100": int,             // 総合スコア: 0から100の整数値
  "confidence": float,            // **判定の確信度: 0.0から1.0の範囲の小数（例: 0.75, 0.85）**
  "qa": [                         // 追加質問のリスト（0〜5個）
    {{
      "question": "string",       // ユーザーへの質問文
      "importance": int,          // 重要度: 1から5の整数（5が最重要）
      "is_ai": bool,              // AI生成フラグ: 通常はtrue
      "project_id": null,         // プロジェクトID（オプション、通常はnull）
      "answer": "string or null"  // 回答例または推奨回答（オプション）
    }}
  ]
}}
```

## 重要な制約と型指定

1. **mvp_feasible**: 必ずboolean型（true または false）で出力
2. **score_0_100**: 0以上100以下の整数値（例: 65, 80, 95）
3. **confidence**: **必ず0.0以上1.0以下の小数値で出力してください**
   - 絶対に1.0を超える値（例: 5, 2.5など）は出力しないでください
   - 確信度が非常に高い場合: 0.85 - 1.0
   - 確信度が高い場合: 0.7 - 0.85
   - 中程度の確信度: 0.5 - 0.7
   - 確信度が低い場合: 0.3 - 0.5
   - 非常に不確実な場合: 0.0 - 0.3
4. **qa配列**: 最低0個、最大5個の質問を含める
   - 要件が十分な場合は空配列 [] を返す
   - 不足がある場合は具体的な質問を生成
5. **importance**: 必ず1から5の整数値（5が最重要）

## 判定基準

- mvp_feasible=true かつ score_0_100 >= 75: 次のステップへ進める
- それ以外の場合: qa配列に追加質問を含め、ユーザーへフィードバックを求める
- confidence < 0.7 の場合: 判定に不確実性があることを示唆

## 出力例

確信度が高い場合:
```json
{{
  "mvp_feasible": true,
  "score_0_100": 85,
  "confidence": 0.88,
  "qa": []
}}
```

確信度が低く追加質問が必要な場合:
```json
{{
  "mvp_feasible": false,
  "score_0_100": 60,
  "confidence": 0.65,
  "qa": [
    {{
      "question": "ユーザー認証の方式は何を想定していますか？（メール/パスワード、OAuth、SNS連携など）",
      "importance": 5,
      "is_ai": true,
      "project_id": null,
      "answer": null
    }},
    {{
      "question": "データの保存期間や削除ポリシーについて決まっていますか？",
      "importance": 4,
      "is_ai": true,
      "project_id": null,
      "answer": null
    }}
  ]
}}
```

要件ドラフト:
{requirements_text}
"""

[technology_service]
generate_technology_document = """
あなたは技術スタックのエキスパートです。以下の選択された技術とフレームワークドキュメントに基づいて、実用的で詳細な技術ドキュメントを生成してください。

選択された技術:
{selected_technologies}

フレームワークドキュメント:
{framework_doc}

## 重要な指示
- 見出しは最大2レベル（## と ###）まで使用
- 実際のURLとコマンドを含める
- 具体的な設定例とコードを提供
- 実務で使える実践的な内容にする

## 必須出力形式
以下の構造で技術ドキュメントを作成してください：

## 技術スタック概要
選択した技術の組み合わせとその役割を説明
- 各技術の用途と特徴
- 技術同士の連携方法

## Docker環境セットアップ
### Dockerfile例
```dockerfile
# 実際に動作するDockerfileの例を記述
```

### docker-compose.yml例
```yaml
# 実際に動作するdocker-compose.ymlの例を記述
```

## インストール手順
### 前提条件
- 必要なソフトウェアとバージョン

### 各技術のインストール
選択された技術ごとに以下を記述：
- インストールコマンド（npm、pip、apt等）
- 設定ファイルの例
- 環境変数の設定

## 公式ドキュメントとリソース
選択された各技術について以下を含める：
- **[技術名]**
  - 公式サイト: [実際のURL]
  - ドキュメント: [実際のURL]
  - 入門ガイド: [実際のURL]

## 動作確認手順
### 環境確認コマンド
```bash
# 各技術が正しくインストールされているかの確認コマンド
```

### 基本的な動作テスト
- アプリケーションの起動方法
- 動作確認の手順
- トラブルシューティング

## よくある問題と解決方法
選択された技術でよく発生する問題と解決策

## 出力例
以下のような具体的な内容を含めてください：

公式ドキュメント例：
- **React**
  - 公式サイト: https://reactjs.org/
  - ドキュメント: https://reactjs.org/docs/getting-started.html
  - 入門ガイド: https://reactjs.org/tutorial/tutorial.html

動作確認例：
```bash
# Node.jsバージョン確認
node --version

# npmバージョン確認
npm --version

# 開発サーバー起動
npm run dev
```

回答はマークダウン形式のみで出力し、```markdown```で囲まないでください。
実際のURL、コマンド、設定例を必ず含めてください。
選択された技術に応じて、適切な公式URLと具体的なコマンドを提供してください。
"""

get_installation_guide = """
あなたは技術インストールのエキスパートです。以下の技術について、詳細なインストールガイドと公式ドキュメント情報を提供してください。

対象技術:
{technology_name}

以下の観点から情報を整理し、JSON形式で回答してください：

1. **installation_steps**: 基本的なインストール手順（配列）
   - OS別の手順があれば明記
   - 必要なコマンドやパッケージマネージャーを含む

2. **docker_setup**: Docker環境でのセットアップ手順（配列）
   - Dockerfileの記述例
   - 必要なベースイメージや環境変数

3. **official_docs**: 公式ドキュメントのURL
   - メインの公式サイト

4. **getting_started_guide**: 入門ガイドのURL
   - チュートリアルやクイックスタート

5. **prerequisites**: 前提条件（配列）
   - 必要なソフトウェアやツール
   - 推奨バージョン情報

{format_instructions}
"""

generate_environment_setup = """
あなたは開発環境構築のエキスパートです。以下の技術スタックを使用したプロジェクトの統合的な開発環境セットアップガイドを作成してください。

選択された技術スタック:
{selected_technologies}

プロジェクトタイプ:
{project_type}

以下の内容を含むマークダウン形式のセットアップガイドを作成してください：

1. **プロジェクト構成概要**
   - 技術スタックの全体像
   - 各技術の役割分担

2. **開発環境要件**
   - 必要なソフトウェアとバージョン
   - OS別の注意事項

3. **統合環境のセットアップ**
   - 全体的なプロジェクト構造の作成
   - 各コンポーネント間の連携設定
   - 環境変数やコンフィグファイルの設定

4. **Docker統合環境**
   - マルチサービス対応のdocker-compose設定
   - 開発用とプロダクション用の設定分離
   - ボリュームマウントとネットワーク設定

5. **開発ワークフロー**
   - 環境の起動・停止手順
   - ホットリロードやライブリロードの設定
   - デバッグ環境の構築

6. **チーム開発のための設定**
   - 統一された開発環境の共有方法
   - linter、formatter等の設定
   - Git hooksやCI/CD連携

回答はマークダウン形式のみで出力し、```markdown```で囲む必要はありません。
"""


